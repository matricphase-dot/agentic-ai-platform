"""
ai_features.py - AI-Powered Features for Automation
Uses Ollama for local AI processing
"""
import json
from typing import List, Dict, Optional
import os

class AIAssistant:
    def __init__(self):
        self.model = "llama3.2"  # Default model
        self.automations_dir = "ai_automations"
        self.history_file = "database/ai_history.json"
        
        # Create directories
        os.makedirs(self.automations_dir, exist_ok=True)
        os.makedirs("database", exist_ok=True)
        
    def generate_automation(self, recording_data: Dict, user_description: str) -> Dict:
        """Generate automation code from recording + description"""
        try:
            # This is a simplified version - in reality, you'd call Ollama API
            # For now, we'll create a template automation
            
            automation_id = f"auto_{len(os.listdir(self.automations_dir)) + 1:04d}"
            filename = f"{self.automations_dir}/{automation_id}.py"
            
            # Create automation template
            automation_code = f'''"""
AI Generated Automation
Recording: {recording_data.get('id', 'unknown')}
User Description: {user_description}
Generated by Agentic AI Assistant
"""

import pyautogui
import time
import keyboard
import os
from datetime import datetime

def log(message):
    """Log messages with timestamp"""
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    print(f"[{{timestamp}}] {{message}}")

def main():
    """Main automation function"""
    log("Starting automation...")
    
    try:
        # YOUR AUTOMATION CODE HERE
        # Based on: {user_description}
        
        # Example steps:
        # 1. Open application
        log("Opening application...")
        pyautogui.hotkey('win', 'r')
        time.sleep(0.5)
        
        # 2. Perform actions
        log("Performing actions...")
        # Add your specific actions here
        
        # 3. Handle completion
        log("Automation completed successfully!")
        
    except Exception as e:
        log(f"Error during automation: {{e}}")
        raise

def safety_check():
    """Safety check before running automation"""
    print("="*50)
    print("SAFETY CHECK")
    print("="*50)
    print("This automation will:")
    print("1. Control mouse and keyboard")
    print("2. Open applications")
    print("3. Perform automated actions")
    print("="*50)
    
    response = input("Continue? (yes/no): ").lower()
    return response == 'yes'

if __name__ == "__main__":
    if safety_check():
        main()
    else:
        print("Automation cancelled by user.")
'''
            
            # Save the automation
            with open(filename, "w") as f:
                f.write(automation_code)
            
            # Save to history
            self._save_to_history({
                "type": "generation",
                "automation_id": automation_id,
                "description": user_description,
                "filename": filename,
                "timestamp": "2024-01-01T10:00:00"  # Replace with actual timestamp
            })
            
            return {
                "success": True,
                "automation_id": automation_id,
                "filename": filename,
                "code_preview": automation_code[:500] + "...",
                "message": "Automation generated successfully"
            }
            
        except Exception as e:
            return {
                "success": False,
                "error": str(e),
                "message": "Failed to generate automation"
            }
    
    def suggest_improvements(self, code: str) -> List[Dict]:
        """Suggest improvements for automation code"""
        suggestions = [
            {
                "type": "performance",
                "description": "Add delay between actions to improve reliability",
                "priority": "high",
                "example": "time.sleep(0.5)  # Add small delay"
            },
            {
                "type": "safety",
                "description": "Add emergency stop hotkey",
                "priority": "high",
                "example": "keyboard.add_hotkey('esc', lambda: exit())"
            },
            {
                "type": "error_handling",
                "description": "Add try-except blocks for error handling",
                "priority": "medium",
                "example": "try:\n    # your code\n except Exception as e:\n    print(f'Error: {e}')"
            }
        ]
        
        return suggestions
    
    def generate_documentation(self, code: str) -> str:
        """Generate documentation for automation code"""
        return f"""
# Automation Documentation

## Purpose
This automation script automates repetitive tasks on your desktop.

## Features
- Mouse and keyboard automation
- Error handling
- Logging system
- Safety checks

## How to Run
1. Ensure Python is installed
2. Install dependencies: `pip install pyautogui keyboard`
3. Run: `python {os.path.basename(code) if isinstance(code, str) else 'automation.py'}`

## Prerequisites
- Python 3.8+
- Required packages: pyautogui, keyboard

## Expected Behavior
The script will perform automated actions as programmed.

## Troubleshooting
- If automation fails, check logs for errors
- Ensure no popups interfere with automation
- Run with administrator privileges if needed
"""
    
    def predict_next_automation(self, user_history: List[Dict]) -> List[Dict]:
        """Predict what automations user might need next"""
        predictions = [
            {
                "title": "File Backup Automation",
                "description": "Automatically backup important files to cloud or external drive",
                "confidence": 0.85,
                "estimated_time_saved": "2 hours/week"
            },
            {
                "title": "Email Organization",
                "description": "Automatically sort and categorize emails",
                "confidence": 0.78,
                "estimated_time_saved": "3 hours/week"
            },
            {
                "title": "Social Media Posting",
                "description": "Schedule and post content to social media platforms",
                "confidence": 0.72,
                "estimated_time_saved": "4 hours/week"
            }
        ]
        
        return predictions
    
    def _save_to_history(self, data: Dict):
        """Save AI interaction to history"""
        history = self._load_history()
        history.append(data)
        
        with open(self.history_file, "w") as f:
            json.dump(history, f, indent=2)
    
    def _load_history(self) -> List[Dict]:
        """Load AI interaction history"""
        if os.path.exists(self.history_file):
            with open(self.history_file, "r") as f:
                return json.load(f)
        return []
    
    def get_statistics(self) -> Dict:
        """Get AI assistant statistics"""
        history = self._load_history()
        
        return {
            "total_generations": len([h for h in history if h.get("type") == "generation"]),
            "total_suggestions": len([h for h in history if h.get("type") == "suggestion"]),
            "automations_created": len(os.listdir(self.automations_dir)) if os.path.exists(self.automations_dir) else 0,
            "last_activity": history[-1]["timestamp"] if history else "Never"
        }

# For testing
if __name__ == "__main__":
    assistant = AIAssistant()
    
    # Test generation
    result = assistant.generate_automation(
        {"id": "test_recording"},
        "Automate file organization on desktop"
    )
    print("Generation result:", result)
    
    # Test suggestions
    suggestions = assistant.suggest_improvements("print('test')")
    print("\nSuggestions:", suggestions)
    
    # Test predictions
    predictions = assistant.predict_next_automation([])
    print("\nPredictions:", predictions)
    
    # Test statistics
    stats = assistant.get_statistics()
    print("\nStatistics:", stats)